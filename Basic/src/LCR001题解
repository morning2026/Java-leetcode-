最开始的算法：暴力求解剪枝
忽略了被除数为0/除数为0的情况

边界 Integer.MIN_VALUE、Integer.MAX_VALUE、0
第一种方法 二分查找 需要重新写一个快速乘函数
快速乘函数讲解：
判断当前z的二进制位
先剪枝再计算
不是一则双倍
z&1 判断奇偶
位运算优先于加减乘除
int mid = l+(r-l)>>1;避免l+r溢出
只有boolean没有bool
int负数比较不容易溢出
加法比减法更容易溢出
按位异或有时候会出错

解法二 类二分查找
传统的二分查找是取中点 但是也可以用2^k<r-l<2^k+1的k值进行类二分查找
用队列来，最初的是b，
填入b的2^k倍。
倒着挨个遍历，类似于找出a的二进制位，用b进制表示a

List 的index是0——size-1，注意函数.get() .add()
+=加()确认优先级
变负数方向要反过来